false = false 0 null undefined NaN '' 0n

삼항 연산자
// 조건 ? 참 : 거짓
console.log(a < 2 ? '참' : '거짓')



표준 내장 객체

01. 문자

const str = 'Hello world!'
               012345678901

console.log(str.length) - 문자의 길이를 반환 - 12

console.log(str.includes('Hello', 0)) - 'Hello'가 포함되어있는지 확인(대소문자 구분) - true
console.log(str.includes('Hello', 1)) - 'Hello'가 포함되어있는지 확인(대소문자 구분) - false (1부터 찾는 거. 맨앞에 H(0) 제외 했으니 없음)

console.log(str.indexOf('world')) - 6 //대상 문자에서 주어진 문자와 일치하는 첫 번째 인덱스(숫자)를 반환
console.log(str.indexOf('Heropy')) - -1 //일치하는 문자가 없으면 '-1'을 반환

console.log(str.padEnd(10, '0')) - 1234567000 // 대상 문자의 길이가 지정된 길이보다 작으면 주어진 문자를 지정된 길이까지 끝에 붙여
console.log(str) - 1234567

console.log(str.padStart(10, '0')) - 0001234567 // End처럼, 뒤가 아닌 앞에 붙임
console.log(str) - 1234567


const str = 'Hello, Hello?!'
console.log(str.replace('Hello'. 'Hi')) - Hi, Hello?! // 대상 문자에서 패턴과 일치하는 부분을 교체한 새로운 문자를 반환
console.log(str.replace(/Hello/g, 'Hi')) - Hi, Hi?! // 슬래쉬 두개 사이에 정규표현식. g=global -> Hello 다 찾아서 바꿔라
console.log(str) - Hello, Hello?!

console.log(str) - Hello world!
console.log(str.slice(0, 5)) - Hello // 대상 문자의 일부를 추출해 새로운 문자를 반환 0~4
console.log(str.slice(6, -1)) - world // 두 번째 인수 직전까지 추출하고, ( -1은 거꾸로 하는 방식. -1이가장 끝(!)
console.log(str.slice(6)) - world! // 두 번째 인수를 생략하면 대상 문자의 끝까지 추출

const str = 'Apple, Banana, Cherry'
console.log(str.split(', ')) - (3) ['Apple', 'Banana', 'Cherry'] // 대상 문자를 주어진 구분자로 나눠 배열로 반환
// ','로로 하면 모양 이상해짐. ''로 하면 한자한자 다 나눔
console.log(str.split(', ').reverse()) - (21) ['y', ~~~ ] reverse - 반대로 해줌.
console.log(str.split(', ').reverse().join()) - yrrehC, ~~~ join - 다 합침

console.log(str.toLowerCase()) - apple, banana, cherry // 영어 소문자로 변환
console.log(str.toUpperCase()) // 대문자로 변환

const str = '    Heropy!   '
console.log(str.trim()) - Heropy! // 앞 뒤의 공백 제거. 사이는 제거하지 않음


숫자

const num = 3.1415926535

console.log(num.toFixed(2)) - 3.14 // 숫자를 지정된 고정 소수점 표기(자릿수)까지 표현하는 문자로 반환
console.log(parseFloat(num.toFixed(2))) - 3.14 // toFixed는 문자이기 때문에 parseFloat으로 숫자로 변환


const num = 1000000

console.log(num.toLocalesString()) - 1,000,000 // 숫자를 현지 언어 형식의 문자로 변환
console.log(`${num.toLocaleString()}원`) - 1,000,000원


const num = 123
const pi = 3.14

console.log(Number.inInteger(num)) - true // 숫자가 정수인지 확인합니다
console.log(Number.inInteger(pi)) - false

console.log(Number.inNaN(??))  NaN = true , 123, 'Hello', null = false //주어진 값이 'NaN인지 확인합니다. Not a Number

const str = '3.1415926535'
const num = 3.1415926535
console.log(Number.parseInt(str, 10)) - 3 // 주어진 값(숫자,문자)을 파싱해 특정 진수(radix)의 정수로 반환. 두번째 인수 10이 10진수 의미.
console.log(Number.parseInt(str, 10)) - 3 // 문자데이터도 숫자데이터도 정수로 만들어주는 거임. Number 제외하고 작성해도 작동함.

console.log(Number.parseFloat(str)) - 3.1415926535 // 주어진 값을 파싱해 부동소수점 실수로 변환(숫자). Number 제외 가능
console.log(parseFloat(num)) - 3.1415926535


수학 - Math 객체
Number 자료형만 지원하며 BigInt와는 사용할 수 없다

console.log(Math.abs(-2)) - 2 // 주어진 숫자의 절댓값을 반환

console.log(Math.ceil(3.1415926535)) - 4 // 올림
console.log(Math.floor(3.1415926535)) - 3 // 내림

console.log(Math.max(1, 22, 38, 192)) - 192 // 가장 큰 숫자 반환
console.log(Math.min(1, 22, 38, 192)) - 1 // 가장 작은 숫자 반환

console.log(Math.pow(4, 2)) - 16 // 거듭제곱 4의 2승
console.log(Math.pow(7, 2)) - 49 // 7의 2승
console.log(Math.pow(10, 3)) - 1000 // 10의 3승

console.log(Math.random()) // 숫자 0 이상, 1미만의 난수를 반환

//특정 범위의 랜덤 정수를 얻는 함수
function random(min = 0, max = 10) {
  return Math.floor(Math.random() * (max - min)) + min
}

console.log(Math.random()) 0~10
console.log(Math.random(11, 20)) 11~20
console.log(Math.random(101, 999)) 101~999

console.log(Math.round(3.14)) - 3 // 반올림


날짜

const date = new Date()
console.log(date) // 타임스탬프 = 'Wed Sep 28 2022 10:45:41 GMT+0900 (한국 표준시)'

const d1 = new Date(2022, 11, 16, 12, 57, 30)
console.log(d1) - Fri Dec 16 2022 12:57:30 ..... - 해당 날짜 표시
console.log(d1.getFullYear()) - 2022 - 날짜만 반환

console.log(date.getFullYear()) - 2022
date.setFullYear(2023)
console.log(date.getFullYear()) - 2023
console.log(date) - 2023 기준 타임스탬프

.getMonth .setMonth // '월' 0부터 시작 (제로베이스드)
.getDate .setDate // '일'
.getHours .setHours
.getMinutues .seMinutes
.getSeconds .setSeconds

.getDay //요일 변환
const date = new Date()
const day = date.getDay()

console.log(day)
console.log(getDayko(day))

function getDayKo(day) {
 switch (day) {
  case 0: return '일요일'
  case 1: return '월요일'
  case 2: return '화요일'
  case 3: return '수요일'
  case 4: return '목요일'
  case 5: return '금요일'
  case 6: return '토요일'
 }
}

.getTime() .setTime() // 유닉스타임 밀리초 반환
console.log(dat)getTime()) - 1666435783 어쩌고 나옴
date.setTime(17000000) - 유닉스 타임 임의로 지정하는 거

Date.now() // 유닉스타임부터 밀리초 반환


배열 array

console.log(arr.legth) - 배열데이터 길이(몇개있냐)

console.log(arr[0])
console.log(arr.at[0]) // 0번째 배열. 음수(-1부터) 입력하면 뒤에서부터 인덱싱

const arr3 = arr1.concat(arr2) - [ A, B, C, D, E, F ] // 배열 병합
const arr3 = [...arr1, ...arr2] // 전개연산자로도 가능

const isValid = arr.every(item => item < 5) - true // 대상 배열의 모든 요소가 콜백 테스트에서 참을 반환하는지 확인
console.log(isValid) - // arr는 1,2,3,4 로 정의했음. 즉 <5니까 트루 맞음.

const filteredNumbers = numbers.filter(number => number <30) // 배열 numbers를 콜백테스트. <30이 true인 값들만 필터해서 반환

const foundItem = arr.find(item => item > 10) // .find() 콜백 테스트를 통과하는 첫 번째 요소를 반환. (크기순이 아니라 배열순)

const index = arr.findIndex(item => item > 10 // 대상 배열에서 콜백 테스트를 통과하는 첫 번째 요소의 인덱스를 반환
console.log(index) // 2(번째)

const arr = [1, 2, [3, 4]]
console.log(arr.flat()) // [1, 2, 3, 4] 모든 하위배열을 지정 깊이(Depth)까지 이어붙인 새로운 배열을 생성. 기본값은 1. 다 하려면 flat(Infinity)

const arr = ['A', 'B', 'C']
arr.forEach(item => console.log(item)) // 대상 배열의 길이만큼 콜백을 실행 -> A B C 순서대로 한번씩 출력
for (let i = 0; i < arr.length; i +=1) {
  console.log(arr[i])
} // A B C 순서대로 한 번씩 출력. A B C 3개니까 3번 반복하는 for 반복문. forEach가 더 단순.

console.log(arr.includes(2)) - true // 대상 배열이 특정 요소를 포함하고 있는지 확인. 2 들어있으면 true. 참조형은 다름. name age 이런 거 묶음

console.log(arr.join()) // 대상 배열의 모든 요소를 구분자로 연결한 문자를 반환. () 안에 , / 등 넣어서 사용. 공백일시 ,

const numbers = [1, 2, 3, 4]
const newNumbers = numbers.map(item => item *2) // 대상 배열의 길이만큼 주어진 콜백을 실행, 콜백의 반환 값을 모아 새로운 배열을 반환
console.log(newNumbers) - [2, 4, 6, 8]

console.log(numbers.pop()) - [1, 2, 3] // 배열의 마지막 요소를 제거하고 반환. 원본이 변경됨.

console.log(numbers.push('넣을거')) - [1, 2, 3, '넣을거'] // 마지막에 하나 이상의 요소를 추가. 새로운 길이를 반환. 원본 변경. 여러개 가능.

const numbers - [1, 2, 3]
const sum = numbers.reduce((accumulator, currentValue) => {    // .reduce() 길이만큼 주어진 콜백 실행. 마지막 값 반환.
  return accumulator + currentValue                                  // 각 콜백의 반환값은 다음 콜백으로 전달. (0+1 -> accumulator)
}, 0}                                                                      // 0=초기값 -> accumulator , 1 -> currentValue
						// acc, cur 로 줄여서 정리하셈
console.log(sum) - 6
// const sum = numbers.reduce((acc, cur) => acc+ cur, 0)

//모든 이름 추출
const namesArray = users.reduce((acc, cur) => {
  acc.push(cur,name)
  return acc
}, [])
const names = namesArray.join(', ')
console.log(names) // users 배열에 name들을 하나씩 push해서 다 합쳐진 값을 반환하고 join을 통해 ,를 사이에 넣어줌.

// 간결화
const names = users.reduce((acc, cur) => {
  acc.push(cur.name)
  return acc
}, []).join(', ')
console.log(names)

const reversed = arr.reverse() // 배열 arr의 순서를 반전함. 원본 변경. A, B, C -> C, B, A

console.log(arr.shift()) - A // 배열에서 첫 번째 요소를 제거하고, 제거된 요소를 반환. 원본이 변경됨
console.log(arr) - B,C // 원본 배열 arr이 A가 제거된 상태로 변경됨.

const arr = [ A ... G ] // .slice() - 대상 배열의 일부를 추출해 새로운 배열을 반환. 두 번째 인수 직전까지 추출. 생략시 끝까지 추출.
console.log(arr.slice(0, 3)) - A, B, C
console.log(arr.slice(4, -1)) - E, F // 음수 사용시 마지막부터 사용. -1(끝)은 G니까 F까지 추출.
console.log(arr.slice(4)) - E, F, G

const arr = [1, 2, 3, 4] //.some() - 대상 배열의 어떤 요소라도 콜백 테스트를 통과하는지 확인
const isValid = arr.some(item => item > 3)
console.log(isValide) - true // 배열에서 하나라도 통과하면 true 나온다는 거. 다 통과 못해야 false 나옴.

const numbers = [4, 17, 2, 103, 3, 1, 0] // .sort() 대상 배열을 콜백의 반환값(음수 양수 0)에 따라 정렬. 원본 변경.

numbers.sort() 	// 콜백 제공하지 않으면 문자열로 변환하고 유니코드 코드 포인트 순서로 정렬
console.log(numbers) - [0, 1, 103, 17, 2, 3, 4]

numbers.sort((a, b) => a - b)
console.log(numbers) - [0, 1, 2, 3, 4, 17, 103] // 양수 - 작은 값부터

numbers.sort((a, b) => b - a )
console.log(numbers) - [103, 17, 4, 3, 2, 1, 0] // 음수 - 큰 값부터

const users = [
  { name: 'Neo', age: 85 },
  { name: 'Amy', age: 22 },
  { name: 'Lewis', age: 11 },
]

users.sort((a, b) => a.age - b.age) // 나이 적은 순으로 정리됨. b.age - a.age 로 하면 큰 순으로.
console.log(users)


const arr = ['A', 'B', 'C']		// .splice() 대상 배열에 요소를 추가or삭제or교체. 원본 벼경
arr.splice(2, 0, 'X') 			// .splice(index번호(3번째), 0(삭제하고자 하는 갯수), 'X'(추가할 글자)) -> 3번째 자리에 삭제 안 하고 X 추가.
console.log(arr) ['A', 'B', 'X', 'C']  	// arr.splice(1, 1) 이렇게 작성하면 'B'만 1개 삭제.

console.log(arr.unshift('X'))		// .unshift() 새로운 요소를 대상 배열의 맨 앞에 추가하고 새로운 배열 길이 반환. 원본 변경.
console.log(arr)			// ['X', 'A', 'B', 'C'] .push()는 맨 뒤인데 .unshift()는 맨 앞. 서로 반대.


//Array.from() 유사 배열(Array-like)을 실제 배열로 반환
const arraylike = {
  0: 'A',
  1: 'B',
  2: 'C',
  length: 3
}
console.log(arraylike.constructor === Array) // false
console.log(arraylike.constructor === Object) // true
// arraylike.forEach(item => console.log(item)) -> 얘는 오류냠. 실제 배열이 아니라서.
Array.from(arraylike).forEach(item => console.log(item)) // A B C 한 줄씩 출력.

const array = ['A', 'B', 'C']

console.log(Array.isArray(array) // true 배열 데이터인지 확인.
console.log(Array.isArray(arraylike) // false


//객체

// Object.assign() 하나 이상의 출처(source) 객체로부터 대상(target) 객체로 속성을 복사하고 대상 객체를 반환
const target = { a: 1, b: 2}
const source1 = { b: 3, c: 4}
const source2 = { c: 5, d: 6}
const result = Object.assign(target, source1, source2) // target 에 source 1, 2 순으로 하나씩 덮어 씌어짐
// const result = Object.assign({},target, source1, source2) 이렇게 하면 target을 수정하지 않고 새로운 {}에 씌어짐.
// const result = {
//  ...target,
//  ...source1,
//  ...source2
// } 전개연산자 ...로 이렇게 작성할 수도 있음.
console.log(target) // {a: 1, b: 3, c: 5, d: 6}
console.log(result) // {a: 1, b: 3, c: 5, d: 6}

// Object.entries() 주어진 객체의 각 속성과 값으로 하나의 배열을 만들어 요소로 추가한 2차원 배열을 반환
const user = {
  name: 'Heropy',
  age: 95,
  isValid: true,
  email: 'thesecon@gmail.com'
}
console.log(Object.entries(user)) {
  console.log(key, value)
} // 2차원 배열로 한 줄씩 나옴

// Object.keys() 주어진 객체의 속성 이름을 나열한 배열을 반환
console.log(Object.keys(user)) // ['name', 'age', 'isValid', 'email']

// Object.values() 주어진 객체의 속성 값을 나열한 배열을 반환
console.log(Object.values(user)) // ['Heropy', 85, true, 'thesecon@gmail.com']



// JSON(JavaScript Object Notation) 데이터 전달을 위한 표준 포멧
// 문자, 숫자, 불린, Null, 객체, 배열 만 사용. 문자는 큰 따옴표만 사용. 후행 쉼표 사용 불가. .json 확장자 사용

// JSON.stringify() - 데이터를 JSON 문자로 변환
// JSON.parse() - JSON 문자를 분석해 데이터로 변환

console.log(JSON.stringify('Hello world'))		// "Hello world!"
console.log(JSON.stringify(123))			// 123
console.log(JSON.stringify(false))			// false
console.log(JSON.stringify(null))			// null
console.log(JSON.stringify({ name: 'Heropy', age: 85 ))	// {"name":"Heropy","age":85}
console.log(JSON.stringify([1, 2, 3]))			// [1,2,3] 얘네 다 문자 데이터

console.log('// --------------------------------//')

console.log(JSON.parse('"Hello world"'))		// Hello world! - 작은 따옴표 없애면 에러 남
console.log(JSON.parse('123'))			// 123
console.log(JSON.parse('false'))			// false
console.log(JSON.parse('null'))			// null
console.log(JSON.parse('{"name":"Heropy","age":85''))	// {name: 'Heropy', age: 85}
console.log(JSON.parse('[1,2,3]'))			// (3) [1, 2, 3]



// 모듈(Module)이란 특정 데이터들의 집합(파일). 가져오기 Import, 내보내기 Export

export const hello = 'Hello world!' 	// midule.js 에서 내보내고
import { hello } from './module.js'
console.log(hello) 			// 'Hello world!' 출력

// 기본 내보내기 module.js
export default 123			// default 방식으로는 하나만 내보낼 수 있음

import number from './module.js'	// 기본 내보내기는 가져올 때 이름 바꿀 수 있음
console.log(number)		// main.js에서 123 잘 출력 됨

// 이름 내보내기
export const str = 'ABC'		// str이란 이름으로 내보냄
export const arr = []		// 배열
export const hello = () => {}		// 함수

import number, { str, arr, hello } from '.module.js'
console.log(str)			// ABC
console.log(arr)			// []
console.log(hello)			// f hello() {}



